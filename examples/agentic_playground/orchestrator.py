"""
Orchestrator - Master Agent for Multi-Agent Coordination

The Orchestrator is the "meta-agent" that:
1. Analyzes the project goal
2. Decides what agents to create
3. Coordinates agent activities
4. Manages the overall workflow
5. Persists learnings through LBM

Enhanced Features (v2):
- Task-based coordination with state machine
- Agent presence monitoring
- Time-aware progress tracking
- Threaded conversations for discussions
"""

import asyncio
import json
import time
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

try:
    from claude_agent_sdk import query, ClaudeAgentOptions
    CLAUDE_SDK_AVAILABLE = True
except ImportError:
    CLAUDE_SDK_AVAILABLE = False

from .agents.factory import AgentFactory
from .agents.base import BaseAgent
from .lbm.coordinator import LBMCoordinator, AgentTask


@dataclass
class ProjectPlan:
    """A plan generated by the orchestrator."""
    goal: str
    agents_needed: List[str]
    phases: List[Dict[str, Any]]
    estimated_tasks: int
    created_at: datetime
    task_ids: List[str] = field(default_factory=list)  # Track created task IDs


class Orchestrator:
    """
    Master orchestrator for multi-agent collaboration.

    The orchestrator:
    1. Analyzes the user's goal
    2. Creates a project plan
    3. Spins up the necessary agents
    4. Coordinates their work
    5. Tracks progress and persists learnings
    """

    ORCHESTRATOR_PROMPT = """You are the Orchestrator, a master AI that coordinates teams of specialized agents.

## Your Role
You analyze project goals, create plans, and coordinate multiple AI agents to accomplish complex tasks.

## Available Agent Types
- **Architect**: Designs system architecture, makes technology decisions
- **Developer**: Writes code, implements features
- **Reviewer**: Reviews code for quality and security
- **Tester**: Creates and runs tests
- **Documenter**: Writes documentation

## Your Capabilities
1. **Analyze Goals**: Break down complex projects into phases
2. **Plan Teams**: Decide which agents are needed
3. **Coordinate Work**: Assign tasks to agents in the right order
4. **Track Progress**: Monitor completion and adjust plans
5. **Share Knowledge**: Ensure insights are shared between agents

## Output Format
When creating plans, use this JSON structure:
```json
{
    "agents_needed": ["architect", "developer", "tester"],
    "phases": [
        {
            "name": "Phase 1: Design",
            "agent": "architect",
            "tasks": ["Define architecture", "Create project structure"]
        },
        {
            "name": "Phase 2: Implementation",
            "agent": "developer",
            "tasks": ["Implement core features", "Add error handling"]
        }
    ]
}
```

## Guidelines
- Start with architecture before implementation
- Include testing for quality assurance
- Add documentation for maintainability
- Share key decisions across agents
"""

    def __init__(
        self,
        work_dir: Path,
        project_name: str = "project",
        *,
        data_dir: Optional[Path] = None,
    ):
        """
        Initialize the orchestrator.

        Args:
            work_dir: Working directory for the project
            project_name: Name of the project
            data_dir: Directory for LBM data (defaults to work_dir/.lbm)
        """
        self.work_dir = Path(work_dir)
        self.work_dir.mkdir(parents=True, exist_ok=True)

        self.project_name = project_name
        self.data_dir = Path(data_dir) if data_dir else self.work_dir / ".lbm"

        # Initialize LBM coordinator
        self.coordinator = LBMCoordinator(
            self.data_dir,
            project_name=project_name,
        )

        # Register orchestrator as an agent
        self.identity = self.coordinator.register_agent("Orchestrator", "orchestrator")

        # Initialize agent factory
        self.factory = AgentFactory(self.coordinator, self.work_dir)

        # Track current plan and progress
        self._plan: Optional[ProjectPlan] = None
        self._agents: Dict[str, BaseAgent] = {}
        self._completed_tasks: List[Dict[str, Any]] = []
        self._task_counter: int = 0
        self._start_time_ms: int = int(time.time() * 1000)

    async def analyze_goal(self, goal: str) -> ProjectPlan:
        """
        Analyze a project goal and create a plan.

        Args:
            goal: The user's project goal

        Returns:
            ProjectPlan with agents and phases
        """
        # Query existing knowledge for relevant context
        context, _ = self.coordinator.query_knowledge("Orchestrator", goal)

        prompt = f"""## Project Goal
{goal}

## Existing Knowledge
{context if context.strip() else "No existing knowledge found."}

## Task
Analyze this goal and create a detailed project plan.

Respond with a JSON object containing:
1. "agents_needed": List of agent roles required
2. "phases": List of phases with tasks for each agent
3. "summary": Brief summary of the approach

Consider:
- What agents are needed for this project?
- What order should the phases proceed?
- What are the key tasks for each phase?
"""

        if not CLAUDE_SDK_AVAILABLE:
            # Return a default plan for testing
            return ProjectPlan(
                goal=goal,
                agents_needed=["architect", "developer", "tester"],
                phases=[
                    {"name": "Design", "agent": "architect", "tasks": ["Design architecture"]},
                    {"name": "Implement", "agent": "developer", "tasks": ["Write code"]},
                    {"name": "Test", "agent": "tester", "tasks": ["Run tests"]},
                ],
                estimated_tasks=3,
                created_at=datetime.now(),
            )

        # Use Claude to create the plan
        options = ClaudeAgentOptions(
            system_prompt=self.ORCHESTRATOR_PROMPT,
            allowed_tools=["Read", "Glob", "Grep"],  # Read-only for planning
            permission_mode="plan",
            cwd=str(self.work_dir),
        )

        plan_json = None
        async for message in query(prompt=prompt, options=options):
            # Look for JSON in the response
            if hasattr(message, 'content'):
                for block in message.content:
                    if hasattr(block, 'text'):
                        text = block.text
                        # Try to extract JSON
                        try:
                            start = text.find('{')
                            end = text.rfind('}') + 1
                            if start >= 0 and end > start:
                                plan_json = json.loads(text[start:end])
                        except json.JSONDecodeError:
                            pass

        if not plan_json:
            # Fallback to default plan
            plan_json = {
                "agents_needed": ["architect", "developer"],
                "phases": [
                    {"name": "Design", "agent": "architect", "tasks": ["Analyze and design"]},
                    {"name": "Implement", "agent": "developer", "tasks": ["Implement features"]},
                ],
            }

        # Share the plan as knowledge
        await self._share_plan(goal, plan_json)

        plan = ProjectPlan(
            goal=goal,
            agents_needed=plan_json.get("agents_needed", []),
            phases=plan_json.get("phases", []),
            estimated_tasks=sum(len(p.get("tasks", [])) for p in plan_json.get("phases", [])),
            created_at=datetime.now(),
        )

        self._plan = plan
        return plan

    async def _share_plan(self, goal: str, plan: Dict[str, Any]) -> None:
        """Share the project plan as knowledge."""
        summary = f"Project Plan for: {goal}\n"
        summary += f"Agents: {', '.join(plan.get('agents_needed', []))}\n"
        summary += f"Phases: {len(plan.get('phases', []))}\n"
        for phase in plan.get("phases", []):
            summary += f"  - {phase.get('name', 'Phase')}: {len(phase.get('tasks', []))} tasks\n"

        self.coordinator.share_knowledge(
            "Orchestrator",
            summary,
            claim_type="decision",
            tags=["plan", "orchestrator"],
        )

    async def setup_team(self, agents_needed: Optional[List[str]] = None) -> Dict[str, BaseAgent]:
        """
        Create the team of agents.

        Args:
            agents_needed: List of agent roles (uses plan if not specified)

        Returns:
            Dict of agent name -> agent
        """
        roles = agents_needed or (self._plan.agents_needed if self._plan else ["architect", "developer"])

        team = self.factory.create_team(preset="custom", custom_roles=roles)
        self._agents = team

        # Share team composition
        team_info = ", ".join(f"{a.config.name} ({a.config.role})" for a in team.values())
        self.coordinator.share_knowledge(
            "Orchestrator",
            f"Team assembled: {team_info}",
            claim_type="decision",
            tags=["team", "setup"],
        )

        return team

    def _generate_task_id(self, prefix: str = "task") -> str:
        """Generate a unique task ID."""
        self._task_counter += 1
        return f"{prefix}_{self._task_counter:04d}"

    async def create_phase_tasks(
        self,
        phase: Dict[str, Any],
        agent_name: str,
    ) -> List[str]:
        """
        Create LBM tasks for a phase.

        Args:
            phase: Phase definition with tasks
            agent_name: Agent to assign tasks to

        Returns:
            List of created task IDs
        """
        phase_name = phase.get("name", "Unnamed Phase")
        tasks = phase.get("tasks", [])
        task_ids = []

        for task_desc in tasks:
            task_id = self._generate_task_id(phase_name.lower().replace(" ", "_")[:10])
            self.coordinator.create_task(
                creator_name="Orchestrator",
                task_id=task_id,
                title=task_desc,
                description=f"Phase: {phase_name}",
                assignee_name=agent_name,
                reward=10,  # Reward per task completion
            )
            task_ids.append(task_id)

        return task_ids

    async def run_phase(self, phase: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute a single phase of the plan using task-based coordination.

        Args:
            phase: Phase definition with agent and tasks

        Returns:
            Phase results
        """
        agent_role = phase.get("agent", "developer")
        phase_name = phase.get("name", "Unnamed Phase")
        tasks = phase.get("tasks", [])

        # Get the agent for this phase
        agent = None
        for a in self._agents.values():
            if a.config.role == agent_role:
                agent = a
                break

        if not agent:
            return {"error": f"No agent found for role: {agent_role}"}

        print(f"\n{'='*60}")
        print(f"Phase: {phase_name}")
        print(f"Agent: {agent.config.name} ({agent.config.role})")
        print(f"Tasks: {len(tasks)}")
        print("="*60)

        # Create LBM tasks for this phase
        task_ids = await self.create_phase_tasks(phase, agent.config.name)
        print(f"  Created {len(task_ids)} tasks in LBM")

        # Update agent presence
        await agent.update_presence("busy", metadata={"phase": phase_name})

        results = []
        for i, task_desc in enumerate(tasks):
            task_id = task_ids[i]
            print(f"\n  [{task_id}] {task_desc}")

            # Start task in LBM
            await agent.start_task(task_id)
            print(f"    Status: in_progress")

            try:
                # Execute the task
                result = await agent.execute_task(task_desc)

                # Share a finding as the result
                finding_hash = await agent.share_insight(
                    f"Completed: {task_desc}",
                    claim_type="task_result",
                    tags=["task", phase_name.lower().replace(" ", "-")],
                )

                # Complete task in LBM with result hash
                await agent.complete_task(task_id, result_hash=finding_hash)
                print(f"    Status: completed ✓")

                results.append({
                    "task_id": task_id,
                    "task": task_desc,
                    "result": result,
                    "result_hash": finding_hash,
                    "agent": agent.config.name,
                    "status": "completed",
                })
            except Exception as e:
                # Mark task as failed
                await agent.fail_task(task_id, error_message=str(e))
                print(f"    Status: failed ✗ ({e})")

                results.append({
                    "task_id": task_id,
                    "task": task_desc,
                    "error": str(e),
                    "agent": agent.config.name,
                    "status": "failed",
                })

            self._completed_tasks.append({
                "phase": phase_name,
                "task_id": task_id,
                "task": task_desc,
                "agent": agent.config.name,
                "completed_at": datetime.now().isoformat(),
            })

        # Update agent presence back to active
        await agent.update_presence("active")

        return {
            "phase": phase_name,
            "agent": agent.config.name,
            "tasks_completed": sum(1 for r in results if r.get("status") == "completed"),
            "tasks_failed": sum(1 for r in results if r.get("status") == "failed"),
            "task_ids": task_ids,
            "results": results,
        }

    async def run(self, goal: str) -> Dict[str, Any]:
        """
        Run the full orchestration loop.

        Args:
            goal: The project goal

        Returns:
            Final results
        """
        print("\n" + "="*60)
        print("  AGENTIC PLAYGROUND")
        print("  Multi-Agent Coordination System")
        print("="*60)
        print(f"\nGoal: {goal}")
        print(f"Work Directory: {self.work_dir}")

        # Phase 1: Analyze and Plan
        print("\n[Orchestrator] Analyzing goal and creating plan...")
        plan = await self.analyze_goal(goal)
        print(f"  Agents needed: {plan.agents_needed}")
        print(f"  Phases: {len(plan.phases)}")

        # Phase 2: Setup Team
        print("\n[Orchestrator] Setting up agent team...")
        team = await self.setup_team()
        for name, agent in team.items():
            print(f"  - {name}: {agent.config.description}")

        # Phase 3: Execute Phases
        print("\n[Orchestrator] Executing project phases...")
        phase_results = []
        for phase in plan.phases:
            result = await self.run_phase(phase)
            phase_results.append(result)

        # Phase 4: Summary
        print("\n" + "="*60)
        print("  PROJECT COMPLETE")
        print("="*60)

        stats = self.coordinator.get_stats()
        print(f"\nKnowledge Base:")
        print(f"  Claims: {stats['claim_count']}")
        print(f"  Total Tokens: {stats['total_supply']}")

        print(f"\nTask Summary:")
        task_stats = stats.get("tasks", {})
        print(f"  Total: {task_stats.get('total', 0)}")
        print(f"  Completed: {task_stats.get('completed', 0)}")
        print(f"  Failed: {task_stats.get('failed', 0)}")

        print(f"\nAgent Status:")
        for name, info in stats.get("agents", {}).items():
            print(f"  - {name}: {info['balance']} tokens ({info.get('status', 'unknown')})")

        # Show active agents
        active = self.coordinator.get_active_agents()
        print(f"\nActive Agents: {', '.join(active) if active else 'None'}")

        # Export learnings
        learnings_file = self.work_dir / "learnings.json"
        self.coordinator.export_learnings(learnings_file)
        print(f"\nLearnings exported to: {learnings_file}")

        # Calculate elapsed time
        elapsed_ms = int(time.time() * 1000) - self._start_time_ms
        elapsed_s = elapsed_ms / 1000

        return {
            "goal": goal,
            "plan": {
                "agents": plan.agents_needed,
                "phases": len(plan.phases),
            },
            "results": phase_results,
            "stats": stats,
            "elapsed_seconds": elapsed_s,
            "learnings_file": str(learnings_file),
        }

    def get_progress(self) -> Dict[str, Any]:
        """Get current progress including task and presence info."""
        stats = self.coordinator.get_stats()
        return {
            "plan": self._plan.__dict__ if self._plan else None,
            "agents": self.factory.get_team_status(),
            "completed_tasks": self._completed_tasks,
            "active_agents": self.coordinator.get_active_agents(),
            "tasks": {
                "total": stats.get("tasks", {}).get("total", 0),
                "in_progress": stats.get("tasks", {}).get("in_progress", 0),
                "completed": stats.get("tasks", {}).get("completed", 0),
                "failed": stats.get("tasks", {}).get("failed", 0),
            },
            "stats": stats,
        }

    def get_knowledge_summary(self) -> List[Dict[str, Any]]:
        """Get summary of all shared knowledge."""
        return self.coordinator.get_all_claims()
